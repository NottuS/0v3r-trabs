\chapter{Implementação}	 
\label{implementacao}
  
\section{Detalhes da implementação}

  O aplicativo implementado nesse trabalho é composto essencialmente por três  classes: MainActivity, 
  Map e WifiInterface. 
  
  A comunicação entre as três classes é feito através da classe Handler(citar) que permite o envio de 
  mensagens entre \textit{threads} e componentes. As principais operações disponíveis no aplicativo não 
  são executadas na \textit{thread} principal, pois, essas operações podem levar muito tempo para serem 
  concluída, assim evitando o problema já discutido anteriormente no capitulo sobre Android,
  de travar a execução da \textit{thread} principal.
  
  \subsection{MainActivity}
  A classe MainActivity é responsável por receber as entradas do usuário e exibir os resultados calculados.
  Ela também é responsável por instanciar as duas outras classes. Há três funções disponíveis: 
  \begin{itemize}
   \item Scan: Obtém o \textit{fingerprint} da força do sinal wifi dos APs na coordenada informada.
   \item Save Table: Salva a tabela de \textit{fingerprints} em um arquivo.
   \item Get Position: Obtém a provável posição do aparelho. 
  \end{itemize}

  A MainActivity cria novas \textit{threads} para executar cada uma das operações requerida pelo o usuário.
  
  \subsection{WifiInterface}
  
  Esta classe centraliza todas as operações envolvendo wifi como verificar e habilitar a conectividade
  com o wifi do aparelho e obter as informações dos APs(força do sinal, nome do AP, endereço, etc) 
  que estão no alcance do aparelho. Para obter essas informações, o objeto dessa classe
  instancia um BroadcastReceiver(citar) que escuta o modulo wifi do aparelho e repassa 
  as informações obtidas através do Handler para o componente que requisitou elas.
  
  \subsection{Map}
  Esta classe é o núcleo da aplicação, ela carrega e armazena o mapa de \textit{fingerprints} de RSS que estão 
  guardadas em arquivo. 
  O \textit{fingerprints} é composto 
  pela coordenada informada pelo usuário e as informações obtidas pela classe WifiInterface. 
  Com o mapa de \textit{fingerprints} essa classe executa o algoritmo descrito a seguir para disponibilizar 
  a atual posição do aparelho.
   
  \subsection{Algoritmo de Localização baseado em \textit{fingerprinting}}
  
  O algoritmo de localização aqui implementado é dividido em duas etapas: aprendizagem e localização. Na etapa de aprendizagem, 
  onde o aplicativo guarda o \textit{fingerprint} dos APs da coordenada informada,
  e salva em uma tabela. O \textit{fingerprint} é composto da média de 8 amostras do RSS de cada AP, média é utilizada 
  devido a grande oscilação do RSS de um AP:
  
  As amostras foram obtidos do primeiro andar do departamento de informática da Universidade Federal do Paraná devido a 
  grande quantidade de APs disponíveis(até treze APs em uma coordenada), a imagem abaixo mostra os locais das amostras retiradas.
  
  A etapa de onde é realizada a localização em si, é dividido em três fases. Primeiramente obtêm-se o \textit{fingerprint}
  o aparelho com Android, da mesma forma feita na etapa de aprendizagem. 
  
  Na segunda fase, para cada três APs do \textit{fingerprint}, utiliza-se a distância Euclidiana, para fazer a comparação com os 
  dados previamente coletados $sqrt((rss1-rss1')^{2}+(rss2-rss2')^{2}+(rss3-rss3')^{2})$, 
e assim encontrar o ponto que mais se aproxima dos parâmetros coletados naquele local. 
Assim obtêm-se um conjunto de pontos que são utilizada na próxima fase.

 
  \begin{comment}
  -Criação da tabela:
    -para a coordenada em questão são obtidas 8 amostras da força do sinal wifi, e é feita a 
    média de cada força de sinal wifi de cada AP.
	- Pois O RSS varia muito(exibir exemplo).
  -Calculo da posição(3 fases):
    - Permite obter a posição do aparelho mesmo sem um fingerprint da posição do aparelho.
	- com as triangulações obtem-se o pontos que se aproxima da posição real.
    -obtem se 8 amostras do APs wifis e faz-se média.
    - para cada 3 APs obtem-se um ponto do mapa.
	- Esse ponto é obtido calculando a menor distância euclidiana entre os APs na amostragem e 
	e os dados salvos na tabela.
    - Com o esse conjunto de pontos, calcula-se o mmq com a biblioteca do apache(citar).
      -Onde obtem se o melhor ponto que resume os pontos obtidos.
    -Colocar imagem.
    \end{comment}
\section{Análise e Resultados Obtidos}

\begin{comment}
  Os experimentos serão realizados no departamento de informática da Universidade Federal do Paraná, 
  devido a grande quantidade de Access Points disponíveis e a disponibilidade da planta do departamento. 
  A implementação do sistema de navegação será dividida em duas etapas:
  \subsection{Etapa 1}
  
  Uma aplicação escrita em C será utilizada para criação do mapa topológico do departamento. Essa aplicação recebe como entrada:
  \begin{itemize}
    \item Uma imagem contendo o mapa.
    \item Tamanho da célula.
  \end{itemize}
 
  A imagem será dividida em células. Em todas as células, serão aplicadas a função de transformação de Hough \cite{openCV}, da biblioteca OpenCV para detecção de linhas. 
  Esta aplicação devolve uma matriz, onde célula possui uma valor que indica o grau de incerteza de haver um obstáculo: 0 (sem obstáculo) ou 4(com obstaculo). 
  Essa matriz será embarcada na aplicação Android da etapa 2.
  
  O tamanho ideal da célula, será definido via experimentos. Em \cite{cnn} o tamanho da célula tem o tamanho do robô. O artigo \cite{dlite} sugere que o tamanho da célula deve 
  comportar todo o obstáculo, lembrando que a quantidade de células pode influênciar no tempo de processamento do planejamento da trajetória do robô \cite{voronoi}.
  
    Uma segunda aplicação Android, será utilizada para coletar amostras, como descrito no método empírico do artigo\cite{wifiRadar}. As tabelas resultantes dessa aplicaçao, também serão 
  embarcada na aplicação Android da etapa 2. As linha da tabela conterão as coordenadas, RSS e nome do AP da amostra daquele local. Vale ressaltar, que número de amostras tem grande impácto 
  na precisão do calculo da localização \cite{wifiRadar}.
  
  \subsection{Etapa 2}
	A aplicação Android dessa etapa, possui 2 componentes principais: uma \textit{Acitivity} \cite{activity} que fará a interação com o usuário, 
	e um Service \cite{service} que fará o processo de navegação do robô. O robô e o tablet, se comunicarão via \textit{bluetooth},
	ou seja, para o funcionamento do sistema, o tablet deve estar pareado com o robô.

	A \textit{Acitivity} irá obter a posição do clique em relação à imagem do mapa, e obter as coordenadas da posição de destino
	 do robô e repassar para o Service. O usuário deve clicar no botão conectar para que a aplicação possa iniciar uma conexão \textit{bluetooth} com o robô.
	Haverá uma imagem com o mapa do ambiente, o usuário deve apontar o local no qual o robô deve atingir. E então clicar no botão iniciar.
	
	Um Service será iniciado, e executará os seguintes passos:
	\begin{itemize}
	  \item O mapa topológico será carregado na memória.
	  \item A posição do robô será calculada, medindo o RSS\cite{wifiRss} dos APs e aplicando o método descrito em \cite{wifiRadar}.
	  \item Em seguida será aplicado o algoritmo A*\cite{aestrela} na matriz gerada na etapa 1. A função h (heurística) levará em consideração o valor da 
	célula(celulas com valor inferior a 3 serão descartados do caminho) e a sua distância euclidiana, em relação a célula destino. 
	  \item Com o trajeto definido, um comando(vetor de bytes indicando distância e direção) será enviado ao robô.
	  \item O Service aguarda o recebimento dos dados do robô.
	  \item Se nenhum obstáculo é encontrado um novo comando é enviado, e processo se repete, até que o robô atinja seu objetivo.
	  \item Se o robô encontrar um novo obstáculo, a célula onde este foi encontrado é incrementado em 1. 
	  Então o processo de descoberta de trajeto é iniciado novamente.
	  \item Se por acaso o robô verificar está célula de novo e não houver obstáculo, o valor da célula é decrementado em 1.
	  \item Se o robô ficar preso, então é adotado um procedimento descrito em \cite{dlite},
	  muros virtuais são criado, para que o robô evite este caminho em uma segunda passagem.
	\end{itemize}
	
	 Aplicação Arduino faz a interface com os motores, o sonar e o adaptator \textit{bluetooth}.
	 Basicamente, ela executa o comando recebido, e então envia os dados coletados pelo sonar e aguarda um novo comando.
\end{comment}